"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/valtio";
exports.ids = ["vendor-chunks/valtio"];
exports.modules = {

/***/ "(ssr)/./node_modules/valtio/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/valtio/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsdGlvL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsaUdBQU87O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87OztBQUdQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIkQ6XFxQcm9qZWN0c1xcdm90aW5nLXN5c3RlbVxcbm9kZV9tb2R1bGVzXFx2YWx0aW9cXG5vZGVfbW9kdWxlc1xcdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmVcXGNqc1xcdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgICAgdmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxuLy8gZGlzcGF0Y2ggZm9yIENvbW1vbkpTIGludGVyb3AgbmFtZWQgaW1wb3J0cy5cblxudmFyIHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUsXG4gICAgdXNlRWZmZWN0ID0gUmVhY3QudXNlRWZmZWN0LFxuICAgIHVzZUxheW91dEVmZmVjdCA9IFJlYWN0LnVzZUxheW91dEVmZmVjdCxcbiAgICB1c2VEZWJ1Z1ZhbHVlID0gUmVhY3QudXNlRGVidWdWYWx1ZTtcbnZhciBkaWRXYXJuT2xkMThBbHBoYSA9IGZhbHNlO1xudmFyIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gZmFsc2U7IC8vIERpc2NsYWltZXI6IFRoaXMgc2hpbSBicmVha3MgbWFueSBvZiB0aGUgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzXG4vLyBiZWNhdXNlIG9mIGEgdmVyeSBwYXJ0aWN1bGFyIHNldCBvZiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGFuZCBhc3N1bXB0aW9uc1xuLy8gLS0gY2hhbmdlIGFueSBvbmUgb2YgdGhlbSBhbmQgaXQgd2lsbCBicmVhay4gVGhlIG1vc3QgaW1wb3J0YW50IGFzc3VtcHRpb25cbi8vIGlzIHRoYXQgdXBkYXRlcyBhcmUgYWx3YXlzIHN5bmNocm9ub3VzLCBiZWNhdXNlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIGlzXG4vLyBvbmx5IGF2YWlsYWJsZSBpbiB2ZXJzaW9ucyBvZiBSZWFjdCB0aGF0IGFsc28gaGF2ZSBhIGJ1aWx0LWluXG4vLyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBBUEkuIEFuZCB3ZSBvbmx5IHVzZSB0aGlzIHNoaW0gd2hlbiB0aGUgYnVpbHQtaW4gQVBJXG4vLyBkb2VzIG5vdCBleGlzdC5cbi8vXG4vLyBEbyBub3QgYXNzdW1lIHRoYXQgdGhlIGNsZXZlciBoYWNrcyB1c2VkIGJ5IHRoaXMgaG9vayBhbHNvIHdvcmsgaW4gZ2VuZXJhbC5cbi8vIFRoZSBwb2ludCBvZiB0aGlzIHNoaW0gaXMgdG8gcmVwbGFjZSB0aGUgbmVlZCBmb3IgaGFja3MgYnkgb3RoZXIgbGlicmFyaWVzLlxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCAvLyBOb3RlOiBUaGUgc2hpbSBkb2VzIG5vdCB1c2UgZ2V0U2VydmVyU25hcHNob3QsIGJlY2F1c2UgcHJlLTE4IHZlcnNpb25zIG9mXG4vLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cbi8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuLy8gZnJvbSBgZ2V0U25hcHNob3RgLlxuZ2V0U2VydmVyU25hcHNob3QpIHtcbiAge1xuICAgIGlmICghZGlkV2Fybk9sZDE4QWxwaGEpIHtcbiAgICAgIGlmIChSZWFjdC5zdGFydFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaWRXYXJuT2xkMThBbHBoYSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1lvdSBhcmUgdXNpbmcgYW4gb3V0ZGF0ZWQsIHByZS1yZWxlYXNlIGFscGhhIG9mIFJlYWN0IDE4IHRoYXQgJyArICdkb2VzIG5vdCBzdXBwb3J0IHVzZVN5bmNFeHRlcm5hbFN0b3JlLiBUaGUgJyArICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZSBzaGltIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5LiBVcGdyYWRlICcgKyAndG8gYSBuZXdlciBwcmUtcmVsZWFzZS4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIEFnYWluLCB0aGlzXG4gIC8vIGJyZWFrcyB0aGUgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzIGhlcmUgYmVjYXVzZSBvZiBzcGVjaWZpY1xuICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLCBtb3N0IGltcG9ydGFudGx5IHRoYXQgdXBkYXRlcyBhcmVcbiAgLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuXG5cbiAgdmFyIHZhbHVlID0gZ2V0U25hcHNob3QoKTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgdmFyIGNhY2hlZFZhbHVlID0gZ2V0U25hcHNob3QoKTtcblxuICAgICAgaWYgKCFvYmplY3RJcyh2YWx1ZSwgY2FjaGVkVmFsdWUpKSB7XG4gICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG4gICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQmVjYXVzZSB1cGRhdGVzIGFyZSBzeW5jaHJvbm91cywgd2UgZG9uJ3QgcXVldWUgdGhlbS4gSW5zdGVhZCB3ZSBmb3JjZSBhXG4gIC8vIHJlLXJlbmRlciB3aGVuZXZlciB0aGUgc3Vic2NyaWJlZCBzdGF0ZSBjaGFuZ2VzIGJ5IHVwZGF0aW5nIGFuIHNvbWVcbiAgLy8gYXJiaXRyYXJ5IHVzZVN0YXRlIGhvb2suIFRoZW4sIGR1cmluZyByZW5kZXIsIHdlIGNhbGwgZ2V0U25hcHNob3QgdG8gcmVhZFxuICAvLyB0aGUgY3VycmVudCB2YWx1ZS5cbiAgLy9cbiAgLy8gQmVjYXVzZSB3ZSBkb24ndCBhY3R1YWxseSB1c2UgdGhlIHN0YXRlIHJldHVybmVkIGJ5IHRoZSB1c2VTdGF0ZSBob29rLCB3ZVxuICAvLyBjYW4gc2F2ZSBhIGJpdCBvZiBtZW1vcnkgYnkgc3RvcmluZyBvdGhlciBzdHVmZiBpbiB0aGF0IHNsb3QuXG4gIC8vXG4gIC8vIFRvIGltcGxlbWVudCB0aGUgZWFybHkgYmFpbG91dCwgd2UgbmVlZCB0byB0cmFjayBzb21lIHRoaW5ncyBvbiBhIG11dGFibGVcbiAgLy8gb2JqZWN0LiBVc3VhbGx5LCB3ZSB3b3VsZCBwdXQgdGhhdCBpbiBhIHVzZVJlZiBob29rLCBidXQgd2UgY2FuIHN0YXNoIGl0IGluXG4gIC8vIG91ciB1c2VTdGF0ZSBob29rIGluc3RlYWQuXG4gIC8vXG4gIC8vIFRvIGZvcmNlIGEgcmUtcmVuZGVyLCB3ZSBjYWxsIGZvcmNlVXBkYXRlKHtpbnN0fSkuIFRoYXQgd29ya3MgYmVjYXVzZSB0aGVcbiAgLy8gbmV3IG9iamVjdCBhbHdheXMgZmFpbHMgYW4gZXF1YWxpdHkgY2hlY2suXG5cblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoe1xuICAgIGluc3Q6IHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdFxuICAgIH1cbiAgfSksXG4gICAgICBpbnN0ID0gX3VzZVN0YXRlWzBdLmluc3QsXG4gICAgICBmb3JjZVVwZGF0ZSA9IF91c2VTdGF0ZVsxXTsgLy8gVHJhY2sgdGhlIGxhdGVzdCBnZXRTbmFwc2hvdCBmdW5jdGlvbiB3aXRoIGEgcmVmLiBUaGlzIG5lZWRzIHRvIGJlIHVwZGF0ZWRcbiAgLy8gaW4gdGhlIGxheW91dCBwaGFzZSBzbyB3ZSBjYW4gYWNjZXNzIGl0IGR1cmluZyB0aGUgdGVhcmluZyBjaGVjayB0aGF0XG4gIC8vIGhhcHBlbnMgb24gc3Vic2NyaWJlLlxuXG5cbiAgdXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gICAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90OyAvLyBXaGVuZXZlciBnZXRTbmFwc2hvdCBvciBzdWJzY3JpYmUgY2hhbmdlcywgd2UgbmVlZCB0byBjaGVjayBpbiB0aGVcbiAgICAvLyBjb21taXQgcGhhc2UgaWYgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIG11dGF0aW9uLiBJbiBjb25jdXJyZW50IG1vZGVcbiAgICAvLyB0aGlzIGNhbiBoYXBwZW4gYWxsIHRoZSB0aW1lLCBidXQgZXZlbiBpbiBzeW5jaHJvbm91cyBtb2RlLCBhbiBlYXJsaWVyXG4gICAgLy8gZWZmZWN0IG1heSBoYXZlIG11dGF0ZWQgdGhlIHN0b3JlLlxuXG4gICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuICAgICAgZm9yY2VVcGRhdGUoe1xuICAgICAgICBpbnN0OiBpbnN0XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtzdWJzY3JpYmUsIHZhbHVlLCBnZXRTbmFwc2hvdF0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIHJpZ2h0IGJlZm9yZSBzdWJzY3JpYmluZy4gU3Vic2VxdWVudCBjaGFuZ2VzIHdpbGwgYmVcbiAgICAvLyBkZXRlY3RlZCBpbiB0aGUgc3Vic2NyaXB0aW9uIGhhbmRsZXIuXG4gICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuICAgICAgZm9yY2VVcGRhdGUoe1xuICAgICAgICBpbnN0OiBpbnN0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlU3RvcmVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPOiBCZWNhdXNlIHRoZXJlIGlzIG5vIGNyb3NzLXJlbmRlcmVyIEFQSSBmb3IgYmF0Y2hpbmcgdXBkYXRlcywgaXQnc1xuICAgICAgLy8gdXAgdG8gdGhlIGNvbnN1bWVyIG9mIHRoaXMgbGlicmFyeSB0byB3cmFwIHRoZWlyIHN1YnNjcmlwdGlvbiBldmVudFxuICAgICAgLy8gd2l0aCB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcy4gU2hvdWxkIHdlIHRyeSB0byBkZXRlY3Qgd2hlbiB0aGlzIGlzbid0XG4gICAgICAvLyB0aGUgY2FzZSBhbmQgcHJpbnQgYSB3YXJuaW5nIGluIGRldmVsb3BtZW50P1xuICAgICAgLy8gVGhlIHN0b3JlIGNoYW5nZWQuIENoZWNrIGlmIHRoZSBzbmFwc2hvdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2VcbiAgICAgIC8vIHJlYWQgZnJvbSB0aGUgc3RvcmUuXG4gICAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgICAgZm9yY2VVcGRhdGUoe1xuICAgICAgICAgIGluc3Q6IGluc3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTsgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIGEgY2xlYW4tdXAgZnVuY3Rpb24uXG5cblxuICAgIHJldHVybiBzdWJzY3JpYmUoaGFuZGxlU3RvcmVDaGFuZ2UpO1xuICB9LCBbc3Vic2NyaWJlXSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkge1xuICB2YXIgbGF0ZXN0R2V0U25hcHNob3QgPSBpbnN0LmdldFNuYXBzaG90O1xuICB2YXIgcHJldlZhbHVlID0gaW5zdC52YWx1ZTtcblxuICB0cnkge1xuICAgIHZhciBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuICAgIHJldHVybiAhb2JqZWN0SXMocHJldlZhbHVlLCBuZXh0VmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuICAvLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cbiAgLy8gd2lsbCBuZWVkIHRvIHRyYWNrIHRoYXQgdGhlbXNlbHZlcyBhbmQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlXG4gIC8vIGZyb20gYGdldFNuYXBzaG90YC5cbiAgcmV0dXJuIGdldFNuYXBzaG90KCk7XG59XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnKTtcblxudmFyIGlzU2VydmVyRW52aXJvbm1lbnQgPSAhY2FuVXNlRE9NO1xuXG52YXIgc2hpbSA9IGlzU2VydmVyRW52aXJvbm1lbnQgPyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxIDogdXNlU3luY0V4dGVybmFsU3RvcmU7XG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmUkMiA9IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlICE9PSB1bmRlZmluZWQgPyBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSA6IHNoaW07XG5cbmV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valtio/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/valtio/node_modules/use-sync-external-store/shim/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/valtio/node_modules/use-sync-external-store/shim/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(ssr)/./node_modules/valtio/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsdGlvL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxrTkFBOEU7QUFDaEYiLCJzb3VyY2VzIjpbIkQ6XFxQcm9qZWN0c1xcdm90aW5nLXN5c3RlbVxcbm9kZV9tb2R1bGVzXFx2YWx0aW9cXG5vZGVfbW9kdWxlc1xcdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmVcXHNoaW1cXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valtio/node_modules/use-sync-external-store/shim/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/valtio/esm/react.mjs":
/*!*******************************************!*\
  !*** ./node_modules/valtio/esm/react.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSnapshot: () => (/* binding */ useSnapshot)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var proxy_compare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! proxy-compare */ \"(ssr)/./node_modules/proxy-compare/dist/index.modern.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/valtio/node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! valtio/vanilla */ \"(ssr)/./node_modules/valtio/esm/vanilla.mjs\");\n\n\n\n\n\nconst { use } = react__WEBPACK_IMPORTED_MODULE_0__;\nconst { useSyncExternalStore } = use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__;\nconst useAffectedDebugValue = (state, affected) => {\n  const pathList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    pathList.current = (0,proxy_compare__WEBPACK_IMPORTED_MODULE_2__.affectedToPathList)(state, affected, true);\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(pathList.current);\n};\nconst targetCache = /* @__PURE__ */ new WeakMap();\nfunction useSnapshot(proxyObject, options) {\n  const notifyInSync = options == null ? void 0 : options.sync;\n  const lastSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  const lastAffected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  let inRender = true;\n  const currSnapshot = useSyncExternalStore(\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (callback) => {\n        const unsub = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_3__.subscribe)(proxyObject, callback, notifyInSync);\n        callback();\n        return unsub;\n      },\n      [proxyObject, notifyInSync]\n    ),\n    () => {\n      const nextSnapshot = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_3__.snapshot)(proxyObject, use);\n      try {\n        if (!inRender && lastSnapshot.current && lastAffected.current && !(0,proxy_compare__WEBPACK_IMPORTED_MODULE_2__.isChanged)(\n          lastSnapshot.current,\n          nextSnapshot,\n          lastAffected.current,\n          /* @__PURE__ */ new WeakMap()\n        )) {\n          return lastSnapshot.current;\n        }\n      } catch (e) {\n      }\n      return nextSnapshot;\n    },\n    () => (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_3__.snapshot)(proxyObject, use)\n  );\n  inRender = false;\n  const currAffected = /* @__PURE__ */ new WeakMap();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    lastSnapshot.current = currSnapshot;\n    lastAffected.current = currAffected;\n  });\n  if (( false ? 0 : void 0) !== \"production\") {\n    useAffectedDebugValue(currSnapshot, currAffected);\n  }\n  const proxyCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);\n  return (0,proxy_compare__WEBPACK_IMPORTED_MODULE_2__.createProxy)(\n    currSnapshot,\n    currAffected,\n    proxyCache,\n    targetCache\n  );\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsdGlvL2VzbS9yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNkY7QUFDbEI7QUFDSztBQUMzQjs7QUFFckQsUUFBUSxNQUFNLEVBQUUsa0NBQVk7QUFDNUIsUUFBUSx1QkFBdUIsRUFBRSxrRUFBMkI7QUFDNUQ7QUFDQSxtQkFBbUIsNkNBQU07QUFDekIsRUFBRSxnREFBUztBQUNYLHVCQUF1QixpRUFBa0I7QUFDekMsR0FBRztBQUNILEVBQUUsb0RBQWE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBTTtBQUM3Qix1QkFBdUIsNkNBQU07QUFDN0I7QUFDQTtBQUNBLElBQUksa0RBQVc7QUFDZjtBQUNBLHNCQUFzQix5REFBUztBQUMvQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBUTtBQUNuQztBQUNBLDBFQUEwRSx3REFBUztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLFVBQVUsd0RBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBTztBQUM1QixTQUFTLDBEQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUIiLCJzb3VyY2VzIjpbIkQ6XFxQcm9qZWN0c1xcdm90aW5nLXN5c3RlbVxcbm9kZV9tb2R1bGVzXFx2YWx0aW9cXGVzbVxccmVhY3QubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdEV4cG9ydHMsIHsgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VEZWJ1Z1ZhbHVlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNDaGFuZ2VkLCBjcmVhdGVQcm94eSwgYWZmZWN0ZWRUb1BhdGhMaXN0IH0gZnJvbSAncHJveHktY29tcGFyZSc7XG5pbXBvcnQgdXNlU3luY0V4dGVybmFsU3RvcmVFeHBvcnRzIGZyb20gJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanMnO1xuaW1wb3J0IHsgc3Vic2NyaWJlLCBzbmFwc2hvdCB9IGZyb20gJ3ZhbHRpby92YW5pbGxhJztcblxuY29uc3QgeyB1c2UgfSA9IFJlYWN0RXhwb3J0cztcbmNvbnN0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlRXhwb3J0cztcbmNvbnN0IHVzZUFmZmVjdGVkRGVidWdWYWx1ZSA9IChzdGF0ZSwgYWZmZWN0ZWQpID0+IHtcbiAgY29uc3QgcGF0aExpc3QgPSB1c2VSZWYoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBwYXRoTGlzdC5jdXJyZW50ID0gYWZmZWN0ZWRUb1BhdGhMaXN0KHN0YXRlLCBhZmZlY3RlZCwgdHJ1ZSk7XG4gIH0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHBhdGhMaXN0LmN1cnJlbnQpO1xufTtcbmNvbnN0IHRhcmdldENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB1c2VTbmFwc2hvdChwcm94eU9iamVjdCwgb3B0aW9ucykge1xuICBjb25zdCBub3RpZnlJblN5bmMgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnN5bmM7XG4gIGNvbnN0IGxhc3RTbmFwc2hvdCA9IHVzZVJlZigpO1xuICBjb25zdCBsYXN0QWZmZWN0ZWQgPSB1c2VSZWYoKTtcbiAgbGV0IGluUmVuZGVyID0gdHJ1ZTtcbiAgY29uc3QgY3VyclNuYXBzaG90ID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgdXNlQ2FsbGJhY2soXG4gICAgICAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgdW5zdWIgPSBzdWJzY3JpYmUocHJveHlPYmplY3QsIGNhbGxiYWNrLCBub3RpZnlJblN5bmMpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm4gdW5zdWI7XG4gICAgICB9LFxuICAgICAgW3Byb3h5T2JqZWN0LCBub3RpZnlJblN5bmNdXG4gICAgKSxcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBuZXh0U25hcHNob3QgPSBzbmFwc2hvdChwcm94eU9iamVjdCwgdXNlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghaW5SZW5kZXIgJiYgbGFzdFNuYXBzaG90LmN1cnJlbnQgJiYgbGFzdEFmZmVjdGVkLmN1cnJlbnQgJiYgIWlzQ2hhbmdlZChcbiAgICAgICAgICBsYXN0U25hcHNob3QuY3VycmVudCxcbiAgICAgICAgICBuZXh0U25hcHNob3QsXG4gICAgICAgICAgbGFzdEFmZmVjdGVkLmN1cnJlbnQsXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgICAgICAgKSkge1xuICAgICAgICAgIHJldHVybiBsYXN0U25hcHNob3QuY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbiAgICB9LFxuICAgICgpID0+IHNuYXBzaG90KHByb3h5T2JqZWN0LCB1c2UpXG4gICk7XG4gIGluUmVuZGVyID0gZmFsc2U7XG4gIGNvbnN0IGN1cnJBZmZlY3RlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxhc3RTbmFwc2hvdC5jdXJyZW50ID0gY3VyclNuYXBzaG90O1xuICAgIGxhc3RBZmZlY3RlZC5jdXJyZW50ID0gY3VyckFmZmVjdGVkO1xuICB9KTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdXNlQWZmZWN0ZWREZWJ1Z1ZhbHVlKGN1cnJTbmFwc2hvdCwgY3VyckFmZmVjdGVkKTtcbiAgfVxuICBjb25zdCBwcm94eUNhY2hlID0gdXNlTWVtbygoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgW10pO1xuICByZXR1cm4gY3JlYXRlUHJveHkoXG4gICAgY3VyclNuYXBzaG90LFxuICAgIGN1cnJBZmZlY3RlZCxcbiAgICBwcm94eUNhY2hlLFxuICAgIHRhcmdldENhY2hlXG4gICk7XG59XG5cbmV4cG9ydCB7IHVzZVNuYXBzaG90IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valtio/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/valtio/esm/vanilla.mjs":
/*!*********************************************!*\
  !*** ./node_modules/valtio/esm/vanilla.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   snapshot: () => (/* binding */ snapshot),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   unstable_buildProxyFunction: () => (/* binding */ unstable_buildProxyFunction)\n/* harmony export */ });\n/* harmony import */ var proxy_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! proxy-compare */ \"(ssr)/./node_modules/proxy-compare/dist/index.modern.js\");\n\n\nconst isObject = (x) => typeof x === \"object\" && x !== null;\nconst proxyStateMap = /* @__PURE__ */ new WeakMap();\nconst refSet = /* @__PURE__ */ new WeakSet();\nconst buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {\n  switch (promise.status) {\n    case \"fulfilled\":\n      return promise.value;\n    case \"rejected\":\n      throw promise.reason;\n    default:\n      throw promise;\n  }\n}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {\n  const cache = snapCache.get(target);\n  if ((cache == null ? void 0 : cache[0]) === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(snap, key)) {\n      return;\n    }\n    const value = Reflect.get(target, key);\n    const desc = {\n      value,\n      enumerable: true,\n      // This is intentional to avoid copying with proxy-compare.\n      // It's still non-writable, so it avoids assigning a value.\n      configurable: true\n    };\n    if (refSet.has(value)) {\n      (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(value, false);\n    } else if (value instanceof Promise) {\n      delete desc.value;\n      desc.get = () => handlePromise(value);\n    } else if (proxyStateMap.has(value)) {\n      const [target2, ensureVersion] = proxyStateMap.get(\n        value\n      );\n      desc.value = createSnapshot(\n        target2,\n        ensureVersion(),\n        handlePromise\n      );\n    }\n    Object.defineProperty(snap, key, desc);\n  });\n  return Object.preventExtensions(snap);\n}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {\n  if (!isObject(initialObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(initialObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */ new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach((listener) => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = (prop) => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */ new Map();\n  const addPropListener = (prop, propProxyState) => {\n    if (( false ? 0 : void 0) !== \"production\" && propProxyStates.has(prop)) {\n      throw new Error(\"prop listener already exists\");\n    }\n    if (listeners.size) {\n      const remove = propProxyState[3](createPropListener(prop));\n      propProxyStates.set(prop, [propProxyState, remove]);\n    } else {\n      propProxyStates.set(prop, [propProxyState]);\n    }\n  };\n  const removePropListener = (prop) => {\n    var _a;\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      (_a = entry[1]) == null ? void 0 : _a.call(entry);\n    }\n  };\n  const addListener = (listener) => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if (( false ? 0 : void 0) !== \"production\" && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const handler = {\n    deleteProperty(target, prop) {\n      const prevValue = Reflect.get(target, prop);\n      removePropListener(prop);\n      const deleted = Reflect.deleteProperty(target, prop);\n      if (deleted) {\n        notifyUpdate([\"delete\", [prop], prevValue]);\n      }\n      return deleted;\n    },\n    set(target, prop, value, receiver) {\n      const hasPrevValue = Reflect.has(target, prop);\n      const prevValue = Reflect.get(target, prop, receiver);\n      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n        return true;\n      }\n      removePropListener(prop);\n      if (isObject(value)) {\n        value = (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.getUntracked)(value) || value;\n      }\n      let nextValue = value;\n      if (value instanceof Promise) {\n        value.then((v) => {\n          value.status = \"fulfilled\";\n          value.value = v;\n          notifyUpdate([\"resolve\", [prop], v]);\n        }).catch((e) => {\n          value.status = \"rejected\";\n          value.reason = e;\n          notifyUpdate([\"reject\", [prop], e]);\n        });\n      } else {\n        if (!proxyStateMap.has(value) && canProxy(value)) {\n          nextValue = proxyFunction(value);\n        }\n        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n        if (childProxyState) {\n          addPropListener(prop, childProxyState);\n        }\n      }\n      Reflect.set(target, prop, nextValue, receiver);\n      notifyUpdate([\"set\", [prop], value, prevValue]);\n      return true;\n    }\n  };\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(initialObject, proxyObject);\n  const proxyState = [\n    baseObject,\n    ensureVersion,\n    createSnapshot,\n    addListener\n  ];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(initialObject).forEach((key) => {\n    const desc = Object.getOwnPropertyDescriptor(\n      initialObject,\n      key\n    );\n    if (\"value\" in desc) {\n      proxyObject[key] = initialObject[key];\n      delete desc.value;\n      delete desc.writable;\n    }\n    Object.defineProperty(baseObject, key, desc);\n  });\n  return proxyObject;\n}) => [\n  // public functions\n  proxyFunction,\n  // shared state\n  proxyStateMap,\n  refSet,\n  // internal things\n  objectIs,\n  newProxy,\n  canProxy,\n  defaultHandlePromise,\n  snapCache,\n  createSnapshot,\n  proxyCache,\n  versionHolder\n];\nconst [defaultProxyFunction] = buildProxyFunction();\nfunction proxy(initialObject = {}) {\n  return defaultProxyFunction(initialObject);\n}\nfunction getVersion(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  return proxyState == null ? void 0 : proxyState[1]();\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (( false ? 0 : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n  const listener = (op) => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject, handlePromise) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (( false ? 0 : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion(), handlePromise);\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\nconst unstable_buildProxyFunction = buildProxyFunction;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsdGlvL2VzbS92YW5pbGxhLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMERBQVc7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBVztBQUNqQixNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQWUsR0FBRyxDQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBZSxHQUFHLENBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBZSxHQUFHLENBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9GIiwic291cmNlcyI6WyJEOlxcUHJvamVjdHNcXHZvdGluZy1zeXN0ZW1cXG5vZGVfbW9kdWxlc1xcdmFsdGlvXFxlc21cXHZhbmlsbGEubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1hcmtUb1RyYWNrLCBnZXRVbnRyYWNrZWQgfSBmcm9tICdwcm94eS1jb21wYXJlJztcblxuY29uc3QgaXNPYmplY3QgPSAoeCkgPT4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbDtcbmNvbnN0IHByb3h5U3RhdGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlZlNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuY29uc3QgYnVpbGRQcm94eUZ1bmN0aW9uID0gKG9iamVjdElzID0gT2JqZWN0LmlzLCBuZXdQcm94eSA9ICh0YXJnZXQsIGhhbmRsZXIpID0+IG5ldyBQcm94eSh0YXJnZXQsIGhhbmRsZXIpLCBjYW5Qcm94eSA9ICh4KSA9PiBpc09iamVjdCh4KSAmJiAhcmVmU2V0Lmhhcyh4KSAmJiAoQXJyYXkuaXNBcnJheSh4KSB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiB4KSkgJiYgISh4IGluc3RhbmNlb2YgV2Vha01hcCkgJiYgISh4IGluc3RhbmNlb2YgV2Vha1NldCkgJiYgISh4IGluc3RhbmNlb2YgRXJyb3IpICYmICEoeCBpbnN0YW5jZW9mIE51bWJlcikgJiYgISh4IGluc3RhbmNlb2YgRGF0ZSkgJiYgISh4IGluc3RhbmNlb2YgU3RyaW5nKSAmJiAhKHggaW5zdGFuY2VvZiBSZWdFeHApICYmICEoeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSwgZGVmYXVsdEhhbmRsZVByb21pc2UgPSAocHJvbWlzZSkgPT4ge1xuICBzd2l0Y2ggKHByb21pc2Uuc3RhdHVzKSB7XG4gICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufSwgc25hcENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGNyZWF0ZVNuYXBzaG90ID0gKHRhcmdldCwgdmVyc2lvbiwgaGFuZGxlUHJvbWlzZSA9IGRlZmF1bHRIYW5kbGVQcm9taXNlKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gc25hcENhY2hlLmdldCh0YXJnZXQpO1xuICBpZiAoKGNhY2hlID09IG51bGwgPyB2b2lkIDAgOiBjYWNoZVswXSkgPT09IHZlcnNpb24pIHtcbiAgICByZXR1cm4gY2FjaGVbMV07XG4gIH1cbiAgY29uc3Qgc25hcCA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KSA/IFtdIDogT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSk7XG4gIG1hcmtUb1RyYWNrKHNuYXAsIHRydWUpO1xuICBzbmFwQ2FjaGUuc2V0KHRhcmdldCwgW3ZlcnNpb24sIHNuYXBdKTtcbiAgUmVmbGVjdC5vd25LZXlzKHRhcmdldCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc25hcCwga2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5KTtcbiAgICBjb25zdCBkZXNjID0ge1xuICAgICAgdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbCB0byBhdm9pZCBjb3B5aW5nIHdpdGggcHJveHktY29tcGFyZS5cbiAgICAgIC8vIEl0J3Mgc3RpbGwgbm9uLXdyaXRhYmxlLCBzbyBpdCBhdm9pZHMgYXNzaWduaW5nIGEgdmFsdWUuXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9O1xuICAgIGlmIChyZWZTZXQuaGFzKHZhbHVlKSkge1xuICAgICAgbWFya1RvVHJhY2sodmFsdWUsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgZGVsZXRlIGRlc2MudmFsdWU7XG4gICAgICBkZXNjLmdldCA9ICgpID0+IGhhbmRsZVByb21pc2UodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJveHlTdGF0ZU1hcC5oYXModmFsdWUpKSB7XG4gICAgICBjb25zdCBbdGFyZ2V0MiwgZW5zdXJlVmVyc2lvbl0gPSBwcm94eVN0YXRlTWFwLmdldChcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBkZXNjLnZhbHVlID0gY3JlYXRlU25hcHNob3QoXG4gICAgICAgIHRhcmdldDIsXG4gICAgICAgIGVuc3VyZVZlcnNpb24oKSxcbiAgICAgICAgaGFuZGxlUHJvbWlzZVxuICAgICAgKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNuYXAsIGtleSwgZGVzYyk7XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHNuYXApO1xufSwgcHJveHlDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCB2ZXJzaW9uSG9sZGVyID0gWzEsIDFdLCBwcm94eUZ1bmN0aW9uID0gKGluaXRpYWxPYmplY3QpID0+IHtcbiAgaWYgKCFpc09iamVjdChpbml0aWFsT2JqZWN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCByZXF1aXJlZFwiKTtcbiAgfVxuICBjb25zdCBmb3VuZCA9IHByb3h5Q2FjaGUuZ2V0KGluaXRpYWxPYmplY3QpO1xuICBpZiAoZm91bmQpIHtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbiAgbGV0IHZlcnNpb24gPSB2ZXJzaW9uSG9sZGVyWzBdO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBub3RpZnlVcGRhdGUgPSAob3AsIG5leHRWZXJzaW9uID0gKyt2ZXJzaW9uSG9sZGVyWzBdKSA9PiB7XG4gICAgaWYgKHZlcnNpb24gIT09IG5leHRWZXJzaW9uKSB7XG4gICAgICB2ZXJzaW9uID0gbmV4dFZlcnNpb247XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKG9wLCBuZXh0VmVyc2lvbikpO1xuICAgIH1cbiAgfTtcbiAgbGV0IGNoZWNrVmVyc2lvbiA9IHZlcnNpb25Ib2xkZXJbMV07XG4gIGNvbnN0IGVuc3VyZVZlcnNpb24gPSAobmV4dENoZWNrVmVyc2lvbiA9ICsrdmVyc2lvbkhvbGRlclsxXSkgPT4ge1xuICAgIGlmIChjaGVja1ZlcnNpb24gIT09IG5leHRDaGVja1ZlcnNpb24gJiYgIWxpc3RlbmVycy5zaXplKSB7XG4gICAgICBjaGVja1ZlcnNpb24gPSBuZXh0Q2hlY2tWZXJzaW9uO1xuICAgICAgcHJvcFByb3h5U3RhdGVzLmZvckVhY2goKFtwcm9wUHJveHlTdGF0ZV0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcFZlcnNpb24gPSBwcm9wUHJveHlTdGF0ZVsxXShuZXh0Q2hlY2tWZXJzaW9uKTtcbiAgICAgICAgaWYgKHByb3BWZXJzaW9uID4gdmVyc2lvbikge1xuICAgICAgICAgIHZlcnNpb24gPSBwcm9wVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9O1xuICBjb25zdCBjcmVhdGVQcm9wTGlzdGVuZXIgPSAocHJvcCkgPT4gKG9wLCBuZXh0VmVyc2lvbikgPT4ge1xuICAgIGNvbnN0IG5ld09wID0gWy4uLm9wXTtcbiAgICBuZXdPcFsxXSA9IFtwcm9wLCAuLi5uZXdPcFsxXV07XG4gICAgbm90aWZ5VXBkYXRlKG5ld09wLCBuZXh0VmVyc2lvbik7XG4gIH07XG4gIGNvbnN0IHByb3BQcm94eVN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGFkZFByb3BMaXN0ZW5lciA9IChwcm9wLCBwcm9wUHJveHlTdGF0ZSkgPT4ge1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcm9wUHJveHlTdGF0ZXMuaGFzKHByb3ApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wIGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXJzLnNpemUpIHtcbiAgICAgIGNvbnN0IHJlbW92ZSA9IHByb3BQcm94eVN0YXRlWzNdKGNyZWF0ZVByb3BMaXN0ZW5lcihwcm9wKSk7XG4gICAgICBwcm9wUHJveHlTdGF0ZXMuc2V0KHByb3AsIFtwcm9wUHJveHlTdGF0ZSwgcmVtb3ZlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BQcm94eVN0YXRlcy5zZXQocHJvcCwgW3Byb3BQcm94eVN0YXRlXSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVQcm9wTGlzdGVuZXIgPSAocHJvcCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBlbnRyeSA9IHByb3BQcm94eVN0YXRlcy5nZXQocHJvcCk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBwcm9wUHJveHlTdGF0ZXMuZGVsZXRlKHByb3ApO1xuICAgICAgKF9hID0gZW50cnlbMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGVudHJ5KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGFkZExpc3RlbmVyID0gKGxpc3RlbmVyKSA9PiB7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgaWYgKGxpc3RlbmVycy5zaXplID09PSAxKSB7XG4gICAgICBwcm9wUHJveHlTdGF0ZXMuZm9yRWFjaCgoW3Byb3BQcm94eVN0YXRlLCBwcmV2UmVtb3ZlXSwgcHJvcCkgPT4ge1xuICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgcHJldlJlbW92ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlbW92ZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdmUgPSBwcm9wUHJveHlTdGF0ZVszXShjcmVhdGVQcm9wTGlzdGVuZXIocHJvcCkpO1xuICAgICAgICBwcm9wUHJveHlTdGF0ZXMuc2V0KHByb3AsIFtwcm9wUHJveHlTdGF0ZSwgcmVtb3ZlXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIGlmIChsaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBwcm9wUHJveHlTdGF0ZXMuZm9yRWFjaCgoW3Byb3BQcm94eVN0YXRlLCByZW1vdmVdLCBwcm9wKSA9PiB7XG4gICAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgICAgICBwcm9wUHJveHlTdGF0ZXMuc2V0KHByb3AsIFtwcm9wUHJveHlTdGF0ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVtb3ZlTGlzdGVuZXI7XG4gIH07XG4gIGNvbnN0IGJhc2VPYmplY3QgPSBBcnJheS5pc0FycmF5KGluaXRpYWxPYmplY3QpID8gW10gOiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbml0aWFsT2JqZWN0KSk7XG4gIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBjb25zdCBwcmV2VmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgcmVtb3ZlUHJvcExpc3RlbmVyKHByb3ApO1xuICAgICAgY29uc3QgZGVsZXRlZCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgIG5vdGlmeVVwZGF0ZShbXCJkZWxldGVcIiwgW3Byb3BdLCBwcmV2VmFsdWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxldGVkO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICBjb25zdCBoYXNQcmV2VmFsdWUgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgY29uc3QgcHJldlZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICBpZiAoaGFzUHJldlZhbHVlICYmIChvYmplY3RJcyhwcmV2VmFsdWUsIHZhbHVlKSB8fCBwcm94eUNhY2hlLmhhcyh2YWx1ZSkgJiYgb2JqZWN0SXMocHJldlZhbHVlLCBwcm94eUNhY2hlLmdldCh2YWx1ZSkpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZVByb3BMaXN0ZW5lcihwcm9wKTtcbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRVbnRyYWNrZWQodmFsdWUpIHx8IHZhbHVlO1xuICAgICAgfVxuICAgICAgbGV0IG5leHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YWx1ZS50aGVuKCh2KSA9PiB7XG4gICAgICAgICAgdmFsdWUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICB2YWx1ZS52YWx1ZSA9IHY7XG4gICAgICAgICAgbm90aWZ5VXBkYXRlKFtcInJlc29sdmVcIiwgW3Byb3BdLCB2XSk7XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgdmFsdWUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHZhbHVlLnJlYXNvbiA9IGU7XG4gICAgICAgICAgbm90aWZ5VXBkYXRlKFtcInJlamVjdFwiLCBbcHJvcF0sIGVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXByb3h5U3RhdGVNYXAuaGFzKHZhbHVlKSAmJiBjYW5Qcm94eSh2YWx1ZSkpIHtcbiAgICAgICAgICBuZXh0VmFsdWUgPSBwcm94eUZ1bmN0aW9uKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZFByb3h5U3RhdGUgPSAhcmVmU2V0LmhhcyhuZXh0VmFsdWUpICYmIHByb3h5U3RhdGVNYXAuZ2V0KG5leHRWYWx1ZSk7XG4gICAgICAgIGlmIChjaGlsZFByb3h5U3RhdGUpIHtcbiAgICAgICAgICBhZGRQcm9wTGlzdGVuZXIocHJvcCwgY2hpbGRQcm94eVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCBuZXh0VmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgIG5vdGlmeVVwZGF0ZShbXCJzZXRcIiwgW3Byb3BdLCB2YWx1ZSwgcHJldlZhbHVlXSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb3h5T2JqZWN0ID0gbmV3UHJveHkoYmFzZU9iamVjdCwgaGFuZGxlcik7XG4gIHByb3h5Q2FjaGUuc2V0KGluaXRpYWxPYmplY3QsIHByb3h5T2JqZWN0KTtcbiAgY29uc3QgcHJveHlTdGF0ZSA9IFtcbiAgICBiYXNlT2JqZWN0LFxuICAgIGVuc3VyZVZlcnNpb24sXG4gICAgY3JlYXRlU25hcHNob3QsXG4gICAgYWRkTGlzdGVuZXJcbiAgXTtcbiAgcHJveHlTdGF0ZU1hcC5zZXQocHJveHlPYmplY3QsIHByb3h5U3RhdGUpO1xuICBSZWZsZWN0Lm93bktleXMoaW5pdGlhbE9iamVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICBpbml0aWFsT2JqZWN0LFxuICAgICAga2V5XG4gICAgKTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICAgIHByb3h5T2JqZWN0W2tleV0gPSBpbml0aWFsT2JqZWN0W2tleV07XG4gICAgICBkZWxldGUgZGVzYy52YWx1ZTtcbiAgICAgIGRlbGV0ZSBkZXNjLndyaXRhYmxlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYmFzZU9iamVjdCwga2V5LCBkZXNjKTtcbiAgfSk7XG4gIHJldHVybiBwcm94eU9iamVjdDtcbn0pID0+IFtcbiAgLy8gcHVibGljIGZ1bmN0aW9uc1xuICBwcm94eUZ1bmN0aW9uLFxuICAvLyBzaGFyZWQgc3RhdGVcbiAgcHJveHlTdGF0ZU1hcCxcbiAgcmVmU2V0LFxuICAvLyBpbnRlcm5hbCB0aGluZ3NcbiAgb2JqZWN0SXMsXG4gIG5ld1Byb3h5LFxuICBjYW5Qcm94eSxcbiAgZGVmYXVsdEhhbmRsZVByb21pc2UsXG4gIHNuYXBDYWNoZSxcbiAgY3JlYXRlU25hcHNob3QsXG4gIHByb3h5Q2FjaGUsXG4gIHZlcnNpb25Ib2xkZXJcbl07XG5jb25zdCBbZGVmYXVsdFByb3h5RnVuY3Rpb25dID0gYnVpbGRQcm94eUZ1bmN0aW9uKCk7XG5mdW5jdGlvbiBwcm94eShpbml0aWFsT2JqZWN0ID0ge30pIHtcbiAgcmV0dXJuIGRlZmF1bHRQcm94eUZ1bmN0aW9uKGluaXRpYWxPYmplY3QpO1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbihwcm94eU9iamVjdCkge1xuICBjb25zdCBwcm94eVN0YXRlID0gcHJveHlTdGF0ZU1hcC5nZXQocHJveHlPYmplY3QpO1xuICByZXR1cm4gcHJveHlTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJveHlTdGF0ZVsxXSgpO1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHByb3h5T2JqZWN0LCBjYWxsYmFjaywgbm90aWZ5SW5TeW5jKSB7XG4gIGNvbnN0IHByb3h5U3RhdGUgPSBwcm94eVN0YXRlTWFwLmdldChwcm94eU9iamVjdCk7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhcHJveHlTdGF0ZSkge1xuICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSB1c2UgcHJveHkgb2JqZWN0XCIpO1xuICB9XG4gIGxldCBwcm9taXNlO1xuICBjb25zdCBvcHMgPSBbXTtcbiAgY29uc3QgYWRkTGlzdGVuZXIgPSBwcm94eVN0YXRlWzNdO1xuICBsZXQgaXNMaXN0ZW5lckFjdGl2ZSA9IGZhbHNlO1xuICBjb25zdCBsaXN0ZW5lciA9IChvcCkgPT4ge1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBpZiAobm90aWZ5SW5TeW5jKSB7XG4gICAgICBjYWxsYmFjayhvcHMuc3BsaWNlKDApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIGlmIChpc0xpc3RlbmVyQWN0aXZlKSB7XG4gICAgICAgICAgY2FsbGJhY2sob3BzLnNwbGljZSgwKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIGlzTGlzdGVuZXJBY3RpdmUgPSB0cnVlO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlzTGlzdGVuZXJBY3RpdmUgPSBmYWxzZTtcbiAgICByZW1vdmVMaXN0ZW5lcigpO1xuICB9O1xufVxuZnVuY3Rpb24gc25hcHNob3QocHJveHlPYmplY3QsIGhhbmRsZVByb21pc2UpIHtcbiAgY29uc3QgcHJveHlTdGF0ZSA9IHByb3h5U3RhdGVNYXAuZ2V0KHByb3h5T2JqZWN0KTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICFwcm94eVN0YXRlKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGxlYXNlIHVzZSBwcm94eSBvYmplY3RcIik7XG4gIH1cbiAgY29uc3QgW3RhcmdldCwgZW5zdXJlVmVyc2lvbiwgY3JlYXRlU25hcHNob3RdID0gcHJveHlTdGF0ZTtcbiAgcmV0dXJuIGNyZWF0ZVNuYXBzaG90KHRhcmdldCwgZW5zdXJlVmVyc2lvbigpLCBoYW5kbGVQcm9taXNlKTtcbn1cbmZ1bmN0aW9uIHJlZihvYmopIHtcbiAgcmVmU2V0LmFkZChvYmopO1xuICByZXR1cm4gb2JqO1xufVxuY29uc3QgdW5zdGFibGVfYnVpbGRQcm94eUZ1bmN0aW9uID0gYnVpbGRQcm94eUZ1bmN0aW9uO1xuXG5leHBvcnQgeyBnZXRWZXJzaW9uLCBwcm94eSwgcmVmLCBzbmFwc2hvdCwgc3Vic2NyaWJlLCB1bnN0YWJsZV9idWlsZFByb3h5RnVuY3Rpb24gfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valtio/esm/vanilla.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/valtio/esm/vanilla/utils.mjs":
/*!***************************************************!*\
  !*** ./node_modules/valtio/esm/vanilla/utils.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addComputed: () => (/* binding */ addComputed_DEPRECATED),\n/* harmony export */   derive: () => (/* binding */ derive),\n/* harmony export */   devtools: () => (/* binding */ devtools),\n/* harmony export */   proxyMap: () => (/* binding */ proxyMap),\n/* harmony export */   proxySet: () => (/* binding */ proxySet),\n/* harmony export */   proxyWithComputed: () => (/* binding */ proxyWithComputed_DEPRECATED),\n/* harmony export */   proxyWithHistory: () => (/* binding */ proxyWithHistory),\n/* harmony export */   subscribeKey: () => (/* binding */ subscribeKey),\n/* harmony export */   underive: () => (/* binding */ underive),\n/* harmony export */   unstable_deriveSubscriptions: () => (/* binding */ unstable_deriveSubscriptions),\n/* harmony export */   watch: () => (/* binding */ watch)\n/* harmony export */ });\n/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! valtio/vanilla */ \"(ssr)/./node_modules/valtio/esm/vanilla.mjs\");\n\n\nfunction subscribeKey(proxyObject, key, callback, notifyInSync) {\n  let prevValue = proxyObject[key];\n  return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.subscribe)(\n    proxyObject,\n    () => {\n      const nextValue = proxyObject[key];\n      if (!Object.is(prevValue, nextValue)) {\n        callback(prevValue = nextValue);\n      }\n    },\n    notifyInSync\n  );\n}\n\nlet currentCleanups;\nfunction watch(callback, options) {\n  let alive = true;\n  const cleanups = /* @__PURE__ */ new Set();\n  const subscriptions = /* @__PURE__ */ new Map();\n  const cleanup = () => {\n    if (alive) {\n      alive = false;\n      cleanups.forEach((clean) => clean());\n      cleanups.clear();\n      subscriptions.forEach((unsubscribe) => unsubscribe());\n      subscriptions.clear();\n    }\n  };\n  const revalidate = () => {\n    if (!alive) {\n      return;\n    }\n    cleanups.forEach((clean) => clean());\n    cleanups.clear();\n    const proxiesToSubscribe = /* @__PURE__ */ new Set();\n    const parent = currentCleanups;\n    currentCleanups = cleanups;\n    try {\n      const cleanupReturn = callback((proxyObject) => {\n        proxiesToSubscribe.add(proxyObject);\n        return proxyObject;\n      });\n      if (cleanupReturn) {\n        cleanups.add(cleanupReturn);\n      }\n    } finally {\n      currentCleanups = parent;\n    }\n    subscriptions.forEach((unsubscribe, proxyObject) => {\n      if (proxiesToSubscribe.has(proxyObject)) {\n        proxiesToSubscribe.delete(proxyObject);\n      } else {\n        subscriptions.delete(proxyObject);\n        unsubscribe();\n      }\n    });\n    proxiesToSubscribe.forEach((proxyObject) => {\n      const unsubscribe = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.subscribe)(proxyObject, revalidate, options == null ? void 0 : options.sync);\n      subscriptions.set(proxyObject, unsubscribe);\n    });\n  };\n  if (currentCleanups) {\n    currentCleanups.add(cleanup);\n  }\n  revalidate();\n  return cleanup;\n}\n\nconst DEVTOOLS = Symbol();\nfunction devtools(proxyObject, options) {\n  if (typeof options === \"string\") {\n    console.warn(\n      \"string name option is deprecated, use { name }. https://github.com/pmndrs/valtio/pull/400\"\n    );\n    options = { name: options };\n  }\n  const { enabled, name = \"\", ...rest } = options || {};\n  let extension;\n  try {\n    extension = (enabled != null ? enabled : ( false ? 0 : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch {\n  }\n  if (!extension) {\n    if (( false ? 0 : void 0) !== \"production\" && enabled) {\n      console.warn(\"[Warning] Please install/enable Redux devtools extension\");\n    }\n    return;\n  }\n  let isTimeTraveling = false;\n  const devtools2 = extension.connect({ name, ...rest });\n  const unsub1 = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.subscribe)(proxyObject, (ops) => {\n    const action = ops.filter(([_, path]) => path[0] !== DEVTOOLS).map(([op, path]) => `${op}:${path.map(String).join(\".\")}`).join(\", \");\n    if (!action) {\n      return;\n    }\n    if (isTimeTraveling) {\n      isTimeTraveling = false;\n    } else {\n      const snapWithoutDevtools = Object.assign({}, (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject));\n      delete snapWithoutDevtools[DEVTOOLS];\n      devtools2.send(\n        {\n          type: action,\n          updatedAt: (/* @__PURE__ */ new Date()).toLocaleString()\n        },\n        snapWithoutDevtools\n      );\n    }\n  });\n  const unsub2 = devtools2.subscribe((message) => {\n    var _a, _b, _c, _d, _e, _f;\n    if (message.type === \"ACTION\" && message.payload) {\n      try {\n        Object.assign(proxyObject, JSON.parse(message.payload));\n      } catch (e) {\n        console.error(\n          \"please dispatch a serializable value that JSON.parse() and proxy() support\\n\",\n          e\n        );\n      }\n    }\n    if (message.type === \"DISPATCH\" && message.state) {\n      if (((_a = message.payload) == null ? void 0 : _a.type) === \"JUMP_TO_ACTION\" || ((_b = message.payload) == null ? void 0 : _b.type) === \"JUMP_TO_STATE\") {\n        isTimeTraveling = true;\n        const state = JSON.parse(message.state);\n        Object.assign(proxyObject, state);\n      }\n      proxyObject[DEVTOOLS] = message;\n    } else if (message.type === \"DISPATCH\" && ((_c = message.payload) == null ? void 0 : _c.type) === \"COMMIT\") {\n      devtools2.init((0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject));\n    } else if (message.type === \"DISPATCH\" && ((_d = message.payload) == null ? void 0 : _d.type) === \"IMPORT_STATE\") {\n      const actions = (_e = message.payload.nextLiftedState) == null ? void 0 : _e.actionsById;\n      const computedStates = ((_f = message.payload.nextLiftedState) == null ? void 0 : _f.computedStates) || [];\n      isTimeTraveling = true;\n      computedStates.forEach(({ state }, index) => {\n        const action = actions[index] || \"No action found\";\n        Object.assign(proxyObject, state);\n        if (index === 0) {\n          devtools2.init((0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject));\n        } else {\n          devtools2.send(action, (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject));\n        }\n      });\n    }\n  });\n  devtools2.init((0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject));\n  return () => {\n    unsub1();\n    unsub2 == null ? void 0 : unsub2();\n  };\n}\n\nconst sourceObjectMap = /* @__PURE__ */ new WeakMap();\nconst derivedObjectMap = /* @__PURE__ */ new WeakMap();\nconst markPending = (sourceObject, callback) => {\n  const sourceObjectEntry = sourceObjectMap.get(sourceObject);\n  if (sourceObjectEntry) {\n    sourceObjectEntry[0].forEach((subscription) => {\n      const { d: derivedObject } = subscription;\n      if (sourceObject !== derivedObject) {\n        markPending(derivedObject);\n      }\n    });\n    ++sourceObjectEntry[2];\n    if (callback) {\n      sourceObjectEntry[3].add(callback);\n    }\n  }\n};\nconst checkPending = (sourceObject, callback) => {\n  const sourceObjectEntry = sourceObjectMap.get(sourceObject);\n  if (sourceObjectEntry == null ? void 0 : sourceObjectEntry[2]) {\n    sourceObjectEntry[3].add(callback);\n    return true;\n  }\n  return false;\n};\nconst unmarkPending = (sourceObject) => {\n  const sourceObjectEntry = sourceObjectMap.get(sourceObject);\n  if (sourceObjectEntry) {\n    --sourceObjectEntry[2];\n    if (!sourceObjectEntry[2]) {\n      sourceObjectEntry[3].forEach((callback) => callback());\n      sourceObjectEntry[3].clear();\n    }\n    sourceObjectEntry[0].forEach((subscription) => {\n      const { d: derivedObject } = subscription;\n      if (sourceObject !== derivedObject) {\n        unmarkPending(derivedObject);\n      }\n    });\n  }\n};\nconst addSubscription = (subscription) => {\n  const { s: sourceObject, d: derivedObject } = subscription;\n  let derivedObjectEntry = derivedObjectMap.get(derivedObject);\n  if (!derivedObjectEntry) {\n    derivedObjectEntry = [/* @__PURE__ */ new Set()];\n    derivedObjectMap.set(subscription.d, derivedObjectEntry);\n  }\n  derivedObjectEntry[0].add(subscription);\n  let sourceObjectEntry = sourceObjectMap.get(sourceObject);\n  if (!sourceObjectEntry) {\n    const subscriptions = /* @__PURE__ */ new Set();\n    const unsubscribe = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.subscribe)(\n      sourceObject,\n      (ops) => {\n        subscriptions.forEach((subscription2) => {\n          const {\n            d: derivedObject2,\n            c: callback,\n            n: notifyInSync,\n            i: ignoreKeys\n          } = subscription2;\n          if (sourceObject === derivedObject2 && ops.every(\n            (op) => op[1].length === 1 && ignoreKeys.includes(op[1][0])\n          )) {\n            return;\n          }\n          if (subscription2.p) {\n            return;\n          }\n          markPending(sourceObject, callback);\n          if (notifyInSync) {\n            unmarkPending(sourceObject);\n          } else {\n            subscription2.p = Promise.resolve().then(() => {\n              delete subscription2.p;\n              unmarkPending(sourceObject);\n            });\n          }\n        });\n      },\n      true\n    );\n    sourceObjectEntry = [subscriptions, unsubscribe, 0, /* @__PURE__ */ new Set()];\n    sourceObjectMap.set(sourceObject, sourceObjectEntry);\n  }\n  sourceObjectEntry[0].add(subscription);\n};\nconst removeSubscription = (subscription) => {\n  const { s: sourceObject, d: derivedObject } = subscription;\n  const derivedObjectEntry = derivedObjectMap.get(derivedObject);\n  derivedObjectEntry == null ? void 0 : derivedObjectEntry[0].delete(subscription);\n  if ((derivedObjectEntry == null ? void 0 : derivedObjectEntry[0].size) === 0) {\n    derivedObjectMap.delete(derivedObject);\n  }\n  const sourceObjectEntry = sourceObjectMap.get(sourceObject);\n  if (sourceObjectEntry) {\n    const [subscriptions, unsubscribe] = sourceObjectEntry;\n    subscriptions.delete(subscription);\n    if (!subscriptions.size) {\n      unsubscribe();\n      sourceObjectMap.delete(sourceObject);\n    }\n  }\n};\nconst listSubscriptions = (derivedObject) => {\n  const derivedObjectEntry = derivedObjectMap.get(derivedObject);\n  if (derivedObjectEntry) {\n    return Array.from(derivedObjectEntry[0]);\n  }\n  return [];\n};\nconst unstable_deriveSubscriptions = {\n  add: addSubscription,\n  remove: removeSubscription,\n  list: listSubscriptions\n};\nfunction derive(derivedFns, options) {\n  const proxyObject = (options == null ? void 0 : options.proxy) || (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.proxy)({});\n  const notifyInSync = !!(options == null ? void 0 : options.sync);\n  const derivedKeys = Object.keys(derivedFns);\n  derivedKeys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(proxyObject, key)) {\n      throw new Error(\"object property already defined\");\n    }\n    const fn = derivedFns[key];\n    let lastDependencies = null;\n    const evaluate = () => {\n      if (lastDependencies) {\n        if (Array.from(lastDependencies).map(([p]) => checkPending(p, evaluate)).some((isPending) => isPending)) {\n          return;\n        }\n        if (Array.from(lastDependencies).every(\n          ([p, entry]) => (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.getVersion)(p) === entry.v\n        )) {\n          return;\n        }\n      }\n      const dependencies = /* @__PURE__ */ new Map();\n      const get = (p) => {\n        dependencies.set(p, { v: (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.getVersion)(p) });\n        return p;\n      };\n      const value = fn(get);\n      const subscribeToDependencies = () => {\n        dependencies.forEach((entry, p) => {\n          var _a;\n          const lastSubscription = (_a = lastDependencies == null ? void 0 : lastDependencies.get(p)) == null ? void 0 : _a.s;\n          if (lastSubscription) {\n            entry.s = lastSubscription;\n          } else {\n            const subscription = {\n              s: p,\n              // sourceObject\n              d: proxyObject,\n              // derivedObject\n              k: key,\n              // derived key\n              c: evaluate,\n              // callback\n              n: notifyInSync,\n              i: derivedKeys\n              // ignoringKeys\n            };\n            addSubscription(subscription);\n            entry.s = subscription;\n          }\n        });\n        lastDependencies == null ? void 0 : lastDependencies.forEach((entry, p) => {\n          if (!dependencies.has(p) && entry.s) {\n            removeSubscription(entry.s);\n          }\n        });\n        lastDependencies = dependencies;\n      };\n      if (value instanceof Promise) {\n        value.finally(subscribeToDependencies);\n      } else {\n        subscribeToDependencies();\n      }\n      proxyObject[key] = value;\n    };\n    evaluate();\n  });\n  return proxyObject;\n}\nfunction underive(proxyObject, options) {\n  const keysToDelete = (options == null ? void 0 : options.delete) ? /* @__PURE__ */ new Set() : null;\n  listSubscriptions(proxyObject).forEach((subscription) => {\n    const { k: key } = subscription;\n    if (!(options == null ? void 0 : options.keys) || options.keys.includes(key)) {\n      removeSubscription(subscription);\n      if (keysToDelete) {\n        keysToDelete.add(key);\n      }\n    }\n  });\n  if (keysToDelete) {\n    keysToDelete.forEach((key) => {\n      delete proxyObject[key];\n    });\n  }\n}\n\nfunction addComputed_DEPRECATED(proxyObject, computedFns_FAKE, targetObject = proxyObject) {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      \"addComputed is deprecated. Please consider using `derive`. Falling back to emulation with derive. https://github.com/pmndrs/valtio/pull/201\"\n    );\n  }\n  const derivedFns = {};\n  Object.keys(computedFns_FAKE).forEach((key) => {\n    derivedFns[key] = (get) => computedFns_FAKE[key](get(proxyObject));\n  });\n  return derive(derivedFns, { proxy: targetObject });\n}\n\nfunction proxyWithComputed_DEPRECATED(initialObject, computedFns) {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      'proxyWithComputed is deprecated. Please follow \"Computed Properties\" guide in docs.'\n    );\n  }\n  Object.keys(computedFns).forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\");\n    }\n    const computedFn = computedFns[key];\n    const { get, set } = typeof computedFn === \"function\" ? { get: computedFn } : computedFn;\n    const desc = {};\n    desc.get = () => get((0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject));\n    if (set) {\n      desc.set = (newValue) => set(proxyObject, newValue);\n    }\n    Object.defineProperty(initialObject, key, desc);\n  });\n  const proxyObject = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.proxy)(initialObject);\n  return proxyObject;\n}\n\nconst isObject = (x) => typeof x === \"object\" && x !== null;\nlet refSet;\nconst deepClone = (obj) => {\n  if (!refSet) {\n    refSet = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.unstable_buildProxyFunction)()[2];\n  }\n  if (!isObject(obj) || refSet.has(obj)) {\n    return obj;\n  }\n  const baseObject = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n  Reflect.ownKeys(obj).forEach((key) => {\n    baseObject[key] = deepClone(obj[key]);\n  });\n  return baseObject;\n};\nfunction proxyWithHistory(initialValue, skipSubscribe = false) {\n  const proxyObject = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.proxy)({\n    value: initialValue,\n    history: (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.ref)({\n      wip: void 0,\n      // to avoid infinite loop\n      snapshots: [],\n      index: -1\n    }),\n    clone: deepClone,\n    canUndo: () => proxyObject.history.index > 0,\n    undo: () => {\n      if (proxyObject.canUndo()) {\n        proxyObject.value = proxyObject.history.wip = proxyObject.clone(\n          proxyObject.history.snapshots[--proxyObject.history.index]\n        );\n      }\n    },\n    canRedo: () => proxyObject.history.index < proxyObject.history.snapshots.length - 1,\n    redo: () => {\n      if (proxyObject.canRedo()) {\n        proxyObject.value = proxyObject.history.wip = proxyObject.clone(\n          proxyObject.history.snapshots[++proxyObject.history.index]\n        );\n      }\n    },\n    saveHistory: () => {\n      proxyObject.history.snapshots.splice(proxyObject.history.index + 1);\n      proxyObject.history.snapshots.push((0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject).value);\n      ++proxyObject.history.index;\n    },\n    subscribe: () => (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.subscribe)(proxyObject, (ops) => {\n      if (ops.every(\n        (op) => op[1][0] === \"value\" && (op[0] !== \"set\" || op[2] !== proxyObject.history.wip)\n      )) {\n        proxyObject.saveHistory();\n      }\n    })\n  });\n  proxyObject.saveHistory();\n  if (!skipSubscribe) {\n    proxyObject.subscribe();\n  }\n  return proxyObject;\n}\n\nfunction proxySet(initialValues) {\n  const set = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.proxy)({\n    data: Array.from(new Set(initialValues)),\n    has(value) {\n      return this.data.indexOf(value) !== -1;\n    },\n    add(value) {\n      let hasProxy = false;\n      if (typeof value === \"object\" && value !== null) {\n        hasProxy = this.data.indexOf((0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.proxy)(value)) !== -1;\n      }\n      if (this.data.indexOf(value) === -1 && !hasProxy) {\n        this.data.push(value);\n      }\n      return this;\n    },\n    delete(value) {\n      const index = this.data.indexOf(value);\n      if (index === -1) {\n        return false;\n      }\n      this.data.splice(index, 1);\n      return true;\n    },\n    clear() {\n      this.data.splice(0);\n    },\n    get size() {\n      return this.data.length;\n    },\n    forEach(cb) {\n      this.data.forEach((value) => {\n        cb(value, value, this);\n      });\n    },\n    get [Symbol.toStringTag]() {\n      return \"Set\";\n    },\n    toJSON() {\n      return new Set(this.data);\n    },\n    [Symbol.iterator]() {\n      return this.data[Symbol.iterator]();\n    },\n    values() {\n      return this.data.values();\n    },\n    keys() {\n      return this.data.values();\n    },\n    entries() {\n      return new Set(this.data).entries();\n    }\n  });\n  Object.defineProperties(set, {\n    data: {\n      enumerable: false\n    },\n    size: {\n      enumerable: false\n    },\n    toJSON: {\n      enumerable: false\n    }\n  });\n  Object.seal(set);\n  return set;\n}\n\nfunction proxyMap(entries) {\n  const map = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.proxy)({\n    data: Array.from(entries || []),\n    has(key) {\n      return this.data.some((p) => p[0] === key);\n    },\n    set(key, value) {\n      const record = this.data.find((p) => p[0] === key);\n      if (record) {\n        record[1] = value;\n      } else {\n        this.data.push([key, value]);\n      }\n      return this;\n    },\n    get(key) {\n      var _a;\n      return (_a = this.data.find((p) => p[0] === key)) == null ? void 0 : _a[1];\n    },\n    delete(key) {\n      const index = this.data.findIndex((p) => p[0] === key);\n      if (index === -1) {\n        return false;\n      }\n      this.data.splice(index, 1);\n      return true;\n    },\n    clear() {\n      this.data.splice(0);\n    },\n    get size() {\n      return this.data.length;\n    },\n    toJSON() {\n      return new Map(this.data);\n    },\n    forEach(cb) {\n      this.data.forEach((p) => {\n        cb(p[1], p[0], this);\n      });\n    },\n    keys() {\n      return this.data.map((p) => p[0]).values();\n    },\n    values() {\n      return this.data.map((p) => p[1]).values();\n    },\n    entries() {\n      return new Map(this.data).entries();\n    },\n    get [Symbol.toStringTag]() {\n      return \"Map\";\n    },\n    [Symbol.iterator]() {\n      return this.entries();\n    }\n  });\n  Object.defineProperties(map, {\n    data: {\n      enumerable: false\n    },\n    size: {\n      enumerable: false\n    },\n    toJSON: {\n      enumerable: false\n    }\n  });\n  Object.seal(map);\n  return map;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsdGlvL2VzbS92YW5pbGxhL3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMEc7O0FBRTFHO0FBQ0E7QUFDQSxTQUFTLHlEQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQix5REFBUztBQUNuQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQTtBQUNBLDhDQUE4QyxNQUFlLEdBQUcsQ0FBb0I7QUFDcEYsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTLE1BQWUsR0FBRyxDQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQsaUJBQWlCLHlEQUFTO0FBQzFCLDBGQUEwRixHQUFHLEdBQUcsMkJBQTJCO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0RBQWtELEVBQUUsd0RBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQkFBcUIsd0RBQVE7QUFDN0IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3REFBUTtBQUNqQyxVQUFVO0FBQ1YsaUNBQWlDLHdEQUFRO0FBQ3pDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILGlCQUFpQix3REFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQ0FBb0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UscURBQUssR0FBRztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixHQUFHLDBEQUFVLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw4QkFBOEIscUJBQXFCO0FBQ25EOztBQUVBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXLHVDQUF1QyxrQkFBa0I7QUFDaEY7QUFDQSx5QkFBeUIsd0RBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLHFEQUFLO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJFQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQUs7QUFDM0I7QUFDQSxhQUFhLG1EQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlDQUF5Qyx3REFBUTtBQUNqRDtBQUNBLEtBQUs7QUFDTCxxQkFBcUIseURBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxxREFBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFEQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxxREFBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRXlOIiwic291cmNlcyI6WyJEOlxcUHJvamVjdHNcXHZvdGluZy1zeXN0ZW1cXG5vZGVfbW9kdWxlc1xcdmFsdGlvXFxlc21cXHZhbmlsbGFcXHV0aWxzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdWJzY3JpYmUsIHNuYXBzaG90LCBwcm94eSwgZ2V0VmVyc2lvbiwgcmVmLCB1bnN0YWJsZV9idWlsZFByb3h5RnVuY3Rpb24gfSBmcm9tICd2YWx0aW8vdmFuaWxsYSc7XG5cbmZ1bmN0aW9uIHN1YnNjcmliZUtleShwcm94eU9iamVjdCwga2V5LCBjYWxsYmFjaywgbm90aWZ5SW5TeW5jKSB7XG4gIGxldCBwcmV2VmFsdWUgPSBwcm94eU9iamVjdFtrZXldO1xuICByZXR1cm4gc3Vic2NyaWJlKFxuICAgIHByb3h5T2JqZWN0LFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHByb3h5T2JqZWN0W2tleV07XG4gICAgICBpZiAoIU9iamVjdC5pcyhwcmV2VmFsdWUsIG5leHRWYWx1ZSkpIHtcbiAgICAgICAgY2FsbGJhY2socHJldlZhbHVlID0gbmV4dFZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5vdGlmeUluU3luY1xuICApO1xufVxuXG5sZXQgY3VycmVudENsZWFudXBzO1xuZnVuY3Rpb24gd2F0Y2goY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgbGV0IGFsaXZlID0gdHJ1ZTtcbiAgY29uc3QgY2xlYW51cHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBzdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICBpZiAoYWxpdmUpIHtcbiAgICAgIGFsaXZlID0gZmFsc2U7XG4gICAgICBjbGVhbnVwcy5mb3JFYWNoKChjbGVhbikgPT4gY2xlYW4oKSk7XG4gICAgICBjbGVhbnVwcy5jbGVhcigpO1xuICAgICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKCh1bnN1YnNjcmliZSkgPT4gdW5zdWJzY3JpYmUoKSk7XG4gICAgICBzdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXZhbGlkYXRlID0gKCkgPT4ge1xuICAgIGlmICghYWxpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYW51cHMuZm9yRWFjaCgoY2xlYW4pID0+IGNsZWFuKCkpO1xuICAgIGNsZWFudXBzLmNsZWFyKCk7XG4gICAgY29uc3QgcHJveGllc1RvU3Vic2NyaWJlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50Q2xlYW51cHM7XG4gICAgY3VycmVudENsZWFudXBzID0gY2xlYW51cHM7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNsZWFudXBSZXR1cm4gPSBjYWxsYmFjaygocHJveHlPYmplY3QpID0+IHtcbiAgICAgICAgcHJveGllc1RvU3Vic2NyaWJlLmFkZChwcm94eU9iamVjdCk7XG4gICAgICAgIHJldHVybiBwcm94eU9iamVjdDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGNsZWFudXBSZXR1cm4pIHtcbiAgICAgICAgY2xlYW51cHMuYWRkKGNsZWFudXBSZXR1cm4pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50Q2xlYW51cHMgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaCgodW5zdWJzY3JpYmUsIHByb3h5T2JqZWN0KSA9PiB7XG4gICAgICBpZiAocHJveGllc1RvU3Vic2NyaWJlLmhhcyhwcm94eU9iamVjdCkpIHtcbiAgICAgICAgcHJveGllc1RvU3Vic2NyaWJlLmRlbGV0ZShwcm94eU9iamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJzY3JpcHRpb25zLmRlbGV0ZShwcm94eU9iamVjdCk7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJveGllc1RvU3Vic2NyaWJlLmZvckVhY2goKHByb3h5T2JqZWN0KSA9PiB7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmliZShwcm94eU9iamVjdCwgcmV2YWxpZGF0ZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zeW5jKTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuc2V0KHByb3h5T2JqZWN0LCB1bnN1YnNjcmliZSk7XG4gICAgfSk7XG4gIH07XG4gIGlmIChjdXJyZW50Q2xlYW51cHMpIHtcbiAgICBjdXJyZW50Q2xlYW51cHMuYWRkKGNsZWFudXApO1xuICB9XG4gIHJldmFsaWRhdGUoKTtcbiAgcmV0dXJuIGNsZWFudXA7XG59XG5cbmNvbnN0IERFVlRPT0xTID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBkZXZ0b29scyhwcm94eU9iamVjdCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcInN0cmluZyBuYW1lIG9wdGlvbiBpcyBkZXByZWNhdGVkLCB1c2UgeyBuYW1lIH0uIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvdmFsdGlvL3B1bGwvNDAwXCJcbiAgICApO1xuICAgIG9wdGlvbnMgPSB7IG5hbWU6IG9wdGlvbnMgfTtcbiAgfVxuICBjb25zdCB7IGVuYWJsZWQsIG5hbWUgPSBcIlwiLCAuLi5yZXN0IH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgZXh0ZW5zaW9uO1xuICB0cnkge1xuICAgIGV4dGVuc2lvbiA9IChlbmFibGVkICE9IG51bGwgPyBlbmFibGVkIDogKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fO1xuICB9IGNhdGNoIHtcbiAgfVxuICBpZiAoIWV4dGVuc2lvbikge1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlbmFibGVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbV2FybmluZ10gUGxlYXNlIGluc3RhbGwvZW5hYmxlIFJlZHV4IGRldnRvb2xzIGV4dGVuc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBpc1RpbWVUcmF2ZWxpbmcgPSBmYWxzZTtcbiAgY29uc3QgZGV2dG9vbHMyID0gZXh0ZW5zaW9uLmNvbm5lY3QoeyBuYW1lLCAuLi5yZXN0IH0pO1xuICBjb25zdCB1bnN1YjEgPSBzdWJzY3JpYmUocHJveHlPYmplY3QsIChvcHMpID0+IHtcbiAgICBjb25zdCBhY3Rpb24gPSBvcHMuZmlsdGVyKChbXywgcGF0aF0pID0+IHBhdGhbMF0gIT09IERFVlRPT0xTKS5tYXAoKFtvcCwgcGF0aF0pID0+IGAke29wfToke3BhdGgubWFwKFN0cmluZykuam9pbihcIi5cIil9YCkuam9pbihcIiwgXCIpO1xuICAgIGlmICghYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1RpbWVUcmF2ZWxpbmcpIHtcbiAgICAgIGlzVGltZVRyYXZlbGluZyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzbmFwV2l0aG91dERldnRvb2xzID0gT2JqZWN0LmFzc2lnbih7fSwgc25hcHNob3QocHJveHlPYmplY3QpKTtcbiAgICAgIGRlbGV0ZSBzbmFwV2l0aG91dERldnRvb2xzW0RFVlRPT0xTXTtcbiAgICAgIGRldnRvb2xzMi5zZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogYWN0aW9uLFxuICAgICAgICAgIHVwZGF0ZWRBdDogKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0xvY2FsZVN0cmluZygpXG4gICAgICAgIH0sXG4gICAgICAgIHNuYXBXaXRob3V0RGV2dG9vbHNcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgdW5zdWIyID0gZGV2dG9vbHMyLnN1YnNjcmliZSgobWVzc2FnZSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiQUNUSU9OXCIgJiYgbWVzc2FnZS5wYXlsb2FkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHByb3h5T2JqZWN0LCBKU09OLnBhcnNlKG1lc3NhZ2UucGF5bG9hZCkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwicGxlYXNlIGRpc3BhdGNoIGEgc2VyaWFsaXphYmxlIHZhbHVlIHRoYXQgSlNPTi5wYXJzZSgpIGFuZCBwcm94eSgpIHN1cHBvcnRcXG5cIixcbiAgICAgICAgICBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiRElTUEFUQ0hcIiAmJiBtZXNzYWdlLnN0YXRlKSB7XG4gICAgICBpZiAoKChfYSA9IG1lc3NhZ2UucGF5bG9hZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSBcIkpVTVBfVE9fQUNUSU9OXCIgfHwgKChfYiA9IG1lc3NhZ2UucGF5bG9hZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnR5cGUpID09PSBcIkpVTVBfVE9fU1RBVEVcIikge1xuICAgICAgICBpc1RpbWVUcmF2ZWxpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UobWVzc2FnZS5zdGF0ZSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocHJveHlPYmplY3QsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHByb3h5T2JqZWN0W0RFVlRPT0xTXSA9IG1lc3NhZ2U7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiRElTUEFUQ0hcIiAmJiAoKF9jID0gbWVzc2FnZS5wYXlsb2FkKSA9PSBudWxsID8gdm9pZCAwIDogX2MudHlwZSkgPT09IFwiQ09NTUlUXCIpIHtcbiAgICAgIGRldnRvb2xzMi5pbml0KHNuYXBzaG90KHByb3h5T2JqZWN0KSk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiRElTUEFUQ0hcIiAmJiAoKF9kID0gbWVzc2FnZS5wYXlsb2FkKSA9PSBudWxsID8gdm9pZCAwIDogX2QudHlwZSkgPT09IFwiSU1QT1JUX1NUQVRFXCIpIHtcbiAgICAgIGNvbnN0IGFjdGlvbnMgPSAoX2UgPSBtZXNzYWdlLnBheWxvYWQubmV4dExpZnRlZFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2UuYWN0aW9uc0J5SWQ7XG4gICAgICBjb25zdCBjb21wdXRlZFN0YXRlcyA9ICgoX2YgPSBtZXNzYWdlLnBheWxvYWQubmV4dExpZnRlZFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2YuY29tcHV0ZWRTdGF0ZXMpIHx8IFtdO1xuICAgICAgaXNUaW1lVHJhdmVsaW5nID0gdHJ1ZTtcbiAgICAgIGNvbXB1dGVkU3RhdGVzLmZvckVhY2goKHsgc3RhdGUgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gYWN0aW9uc1tpbmRleF0gfHwgXCJObyBhY3Rpb24gZm91bmRcIjtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm94eU9iamVjdCwgc3RhdGUpO1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBkZXZ0b29sczIuaW5pdChzbmFwc2hvdChwcm94eU9iamVjdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRldnRvb2xzMi5zZW5kKGFjdGlvbiwgc25hcHNob3QocHJveHlPYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgZGV2dG9vbHMyLmluaXQoc25hcHNob3QocHJveHlPYmplY3QpKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB1bnN1YjEoKTtcbiAgICB1bnN1YjIgPT0gbnVsbCA/IHZvaWQgMCA6IHVuc3ViMigpO1xuICB9O1xufVxuXG5jb25zdCBzb3VyY2VPYmplY3RNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGRlcml2ZWRPYmplY3RNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG1hcmtQZW5kaW5nID0gKHNvdXJjZU9iamVjdCwgY2FsbGJhY2spID0+IHtcbiAgY29uc3Qgc291cmNlT2JqZWN0RW50cnkgPSBzb3VyY2VPYmplY3RNYXAuZ2V0KHNvdXJjZU9iamVjdCk7XG4gIGlmIChzb3VyY2VPYmplY3RFbnRyeSkge1xuICAgIHNvdXJjZU9iamVjdEVudHJ5WzBdLmZvckVhY2goKHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgY29uc3QgeyBkOiBkZXJpdmVkT2JqZWN0IH0gPSBzdWJzY3JpcHRpb247XG4gICAgICBpZiAoc291cmNlT2JqZWN0ICE9PSBkZXJpdmVkT2JqZWN0KSB7XG4gICAgICAgIG1hcmtQZW5kaW5nKGRlcml2ZWRPYmplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgICsrc291cmNlT2JqZWN0RW50cnlbMl07XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBzb3VyY2VPYmplY3RFbnRyeVszXS5hZGQoY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGNoZWNrUGVuZGluZyA9IChzb3VyY2VPYmplY3QsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IHNvdXJjZU9iamVjdEVudHJ5ID0gc291cmNlT2JqZWN0TWFwLmdldChzb3VyY2VPYmplY3QpO1xuICBpZiAoc291cmNlT2JqZWN0RW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHNvdXJjZU9iamVjdEVudHJ5WzJdKSB7XG4gICAgc291cmNlT2JqZWN0RW50cnlbM10uYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgdW5tYXJrUGVuZGluZyA9IChzb3VyY2VPYmplY3QpID0+IHtcbiAgY29uc3Qgc291cmNlT2JqZWN0RW50cnkgPSBzb3VyY2VPYmplY3RNYXAuZ2V0KHNvdXJjZU9iamVjdCk7XG4gIGlmIChzb3VyY2VPYmplY3RFbnRyeSkge1xuICAgIC0tc291cmNlT2JqZWN0RW50cnlbMl07XG4gICAgaWYgKCFzb3VyY2VPYmplY3RFbnRyeVsyXSkge1xuICAgICAgc291cmNlT2JqZWN0RW50cnlbM10uZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgICAgc291cmNlT2JqZWN0RW50cnlbM10uY2xlYXIoKTtcbiAgICB9XG4gICAgc291cmNlT2JqZWN0RW50cnlbMF0uZm9yRWFjaCgoc3Vic2NyaXB0aW9uKSA9PiB7XG4gICAgICBjb25zdCB7IGQ6IGRlcml2ZWRPYmplY3QgfSA9IHN1YnNjcmlwdGlvbjtcbiAgICAgIGlmIChzb3VyY2VPYmplY3QgIT09IGRlcml2ZWRPYmplY3QpIHtcbiAgICAgICAgdW5tYXJrUGVuZGluZyhkZXJpdmVkT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmNvbnN0IGFkZFN1YnNjcmlwdGlvbiA9IChzdWJzY3JpcHRpb24pID0+IHtcbiAgY29uc3QgeyBzOiBzb3VyY2VPYmplY3QsIGQ6IGRlcml2ZWRPYmplY3QgfSA9IHN1YnNjcmlwdGlvbjtcbiAgbGV0IGRlcml2ZWRPYmplY3RFbnRyeSA9IGRlcml2ZWRPYmplY3RNYXAuZ2V0KGRlcml2ZWRPYmplY3QpO1xuICBpZiAoIWRlcml2ZWRPYmplY3RFbnRyeSkge1xuICAgIGRlcml2ZWRPYmplY3RFbnRyeSA9IFsvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXTtcbiAgICBkZXJpdmVkT2JqZWN0TWFwLnNldChzdWJzY3JpcHRpb24uZCwgZGVyaXZlZE9iamVjdEVudHJ5KTtcbiAgfVxuICBkZXJpdmVkT2JqZWN0RW50cnlbMF0uYWRkKHN1YnNjcmlwdGlvbik7XG4gIGxldCBzb3VyY2VPYmplY3RFbnRyeSA9IHNvdXJjZU9iamVjdE1hcC5nZXQoc291cmNlT2JqZWN0KTtcbiAgaWYgKCFzb3VyY2VPYmplY3RFbnRyeSkge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3Vic2NyaWJlKFxuICAgICAgc291cmNlT2JqZWN0LFxuICAgICAgKG9wcykgPT4ge1xuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YnNjcmlwdGlvbjIpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkOiBkZXJpdmVkT2JqZWN0MixcbiAgICAgICAgICAgIGM6IGNhbGxiYWNrLFxuICAgICAgICAgICAgbjogbm90aWZ5SW5TeW5jLFxuICAgICAgICAgICAgaTogaWdub3JlS2V5c1xuICAgICAgICAgIH0gPSBzdWJzY3JpcHRpb24yO1xuICAgICAgICAgIGlmIChzb3VyY2VPYmplY3QgPT09IGRlcml2ZWRPYmplY3QyICYmIG9wcy5ldmVyeShcbiAgICAgICAgICAgIChvcCkgPT4gb3BbMV0ubGVuZ3RoID09PSAxICYmIGlnbm9yZUtleXMuaW5jbHVkZXMob3BbMV1bMF0pXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uMi5wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcmtQZW5kaW5nKHNvdXJjZU9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChub3RpZnlJblN5bmMpIHtcbiAgICAgICAgICAgIHVubWFya1BlbmRpbmcoc291cmNlT2JqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uMi5wID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdWJzY3JpcHRpb24yLnA7XG4gICAgICAgICAgICAgIHVubWFya1BlbmRpbmcoc291cmNlT2JqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgc291cmNlT2JqZWN0RW50cnkgPSBbc3Vic2NyaXB0aW9ucywgdW5zdWJzY3JpYmUsIDAsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCldO1xuICAgIHNvdXJjZU9iamVjdE1hcC5zZXQoc291cmNlT2JqZWN0LCBzb3VyY2VPYmplY3RFbnRyeSk7XG4gIH1cbiAgc291cmNlT2JqZWN0RW50cnlbMF0uYWRkKHN1YnNjcmlwdGlvbik7XG59O1xuY29uc3QgcmVtb3ZlU3Vic2NyaXB0aW9uID0gKHN1YnNjcmlwdGlvbikgPT4ge1xuICBjb25zdCB7IHM6IHNvdXJjZU9iamVjdCwgZDogZGVyaXZlZE9iamVjdCB9ID0gc3Vic2NyaXB0aW9uO1xuICBjb25zdCBkZXJpdmVkT2JqZWN0RW50cnkgPSBkZXJpdmVkT2JqZWN0TWFwLmdldChkZXJpdmVkT2JqZWN0KTtcbiAgZGVyaXZlZE9iamVjdEVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBkZXJpdmVkT2JqZWN0RW50cnlbMF0uZGVsZXRlKHN1YnNjcmlwdGlvbik7XG4gIGlmICgoZGVyaXZlZE9iamVjdEVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBkZXJpdmVkT2JqZWN0RW50cnlbMF0uc2l6ZSkgPT09IDApIHtcbiAgICBkZXJpdmVkT2JqZWN0TWFwLmRlbGV0ZShkZXJpdmVkT2JqZWN0KTtcbiAgfVxuICBjb25zdCBzb3VyY2VPYmplY3RFbnRyeSA9IHNvdXJjZU9iamVjdE1hcC5nZXQoc291cmNlT2JqZWN0KTtcbiAgaWYgKHNvdXJjZU9iamVjdEVudHJ5KSB7XG4gICAgY29uc3QgW3N1YnNjcmlwdGlvbnMsIHVuc3Vic2NyaWJlXSA9IHNvdXJjZU9iamVjdEVudHJ5O1xuICAgIHN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbik7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25zLnNpemUpIHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICBzb3VyY2VPYmplY3RNYXAuZGVsZXRlKHNvdXJjZU9iamVjdCk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgbGlzdFN1YnNjcmlwdGlvbnMgPSAoZGVyaXZlZE9iamVjdCkgPT4ge1xuICBjb25zdCBkZXJpdmVkT2JqZWN0RW50cnkgPSBkZXJpdmVkT2JqZWN0TWFwLmdldChkZXJpdmVkT2JqZWN0KTtcbiAgaWYgKGRlcml2ZWRPYmplY3RFbnRyeSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGRlcml2ZWRPYmplY3RFbnRyeVswXSk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcbmNvbnN0IHVuc3RhYmxlX2Rlcml2ZVN1YnNjcmlwdGlvbnMgPSB7XG4gIGFkZDogYWRkU3Vic2NyaXB0aW9uLFxuICByZW1vdmU6IHJlbW92ZVN1YnNjcmlwdGlvbixcbiAgbGlzdDogbGlzdFN1YnNjcmlwdGlvbnNcbn07XG5mdW5jdGlvbiBkZXJpdmUoZGVyaXZlZEZucywgb3B0aW9ucykge1xuICBjb25zdCBwcm94eU9iamVjdCA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnByb3h5KSB8fCBwcm94eSh7fSk7XG4gIGNvbnN0IG5vdGlmeUluU3luYyA9ICEhKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3luYyk7XG4gIGNvbnN0IGRlcml2ZWRLZXlzID0gT2JqZWN0LmtleXMoZGVyaXZlZEZucyk7XG4gIGRlcml2ZWRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5T2JqZWN0LCBrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgcHJvcGVydHkgYWxyZWFkeSBkZWZpbmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBmbiA9IGRlcml2ZWRGbnNba2V5XTtcbiAgICBsZXQgbGFzdERlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgY29uc3QgZXZhbHVhdGUgPSAoKSA9PiB7XG4gICAgICBpZiAobGFzdERlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoQXJyYXkuZnJvbShsYXN0RGVwZW5kZW5jaWVzKS5tYXAoKFtwXSkgPT4gY2hlY2tQZW5kaW5nKHAsIGV2YWx1YXRlKSkuc29tZSgoaXNQZW5kaW5nKSA9PiBpc1BlbmRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5mcm9tKGxhc3REZXBlbmRlbmNpZXMpLmV2ZXJ5KFxuICAgICAgICAgIChbcCwgZW50cnldKSA9PiBnZXRWZXJzaW9uKHApID09PSBlbnRyeS52XG4gICAgICAgICkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBnZXQgPSAocCkgPT4ge1xuICAgICAgICBkZXBlbmRlbmNpZXMuc2V0KHAsIHsgdjogZ2V0VmVyc2lvbihwKSB9KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9O1xuICAgICAgY29uc3QgdmFsdWUgPSBmbihnZXQpO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlVG9EZXBlbmRlbmNpZXMgPSAoKSA9PiB7XG4gICAgICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoKChlbnRyeSwgcCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBjb25zdCBsYXN0U3Vic2NyaXB0aW9uID0gKF9hID0gbGFzdERlcGVuZGVuY2llcyA9PSBudWxsID8gdm9pZCAwIDogbGFzdERlcGVuZGVuY2llcy5nZXQocCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zO1xuICAgICAgICAgIGlmIChsYXN0U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBlbnRyeS5zID0gbGFzdFN1YnNjcmlwdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgICBzOiBwLFxuICAgICAgICAgICAgICAvLyBzb3VyY2VPYmplY3RcbiAgICAgICAgICAgICAgZDogcHJveHlPYmplY3QsXG4gICAgICAgICAgICAgIC8vIGRlcml2ZWRPYmplY3RcbiAgICAgICAgICAgICAgazoga2V5LFxuICAgICAgICAgICAgICAvLyBkZXJpdmVkIGtleVxuICAgICAgICAgICAgICBjOiBldmFsdWF0ZSxcbiAgICAgICAgICAgICAgLy8gY2FsbGJhY2tcbiAgICAgICAgICAgICAgbjogbm90aWZ5SW5TeW5jLFxuICAgICAgICAgICAgICBpOiBkZXJpdmVkS2V5c1xuICAgICAgICAgICAgICAvLyBpZ25vcmluZ0tleXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhZGRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGVudHJ5LnMgPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdERlcGVuZGVuY2llcyA9PSBudWxsID8gdm9pZCAwIDogbGFzdERlcGVuZGVuY2llcy5mb3JFYWNoKChlbnRyeSwgcCkgPT4ge1xuICAgICAgICAgIGlmICghZGVwZW5kZW5jaWVzLmhhcyhwKSAmJiBlbnRyeS5zKSB7XG4gICAgICAgICAgICByZW1vdmVTdWJzY3JpcHRpb24oZW50cnkucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdERlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgIH07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhbHVlLmZpbmFsbHkoc3Vic2NyaWJlVG9EZXBlbmRlbmNpZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3Vic2NyaWJlVG9EZXBlbmRlbmNpZXMoKTtcbiAgICAgIH1cbiAgICAgIHByb3h5T2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIGV2YWx1YXRlKCk7XG4gIH0pO1xuICByZXR1cm4gcHJveHlPYmplY3Q7XG59XG5mdW5jdGlvbiB1bmRlcml2ZShwcm94eU9iamVjdCwgb3B0aW9ucykge1xuICBjb25zdCBrZXlzVG9EZWxldGUgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kZWxldGUpID8gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSA6IG51bGw7XG4gIGxpc3RTdWJzY3JpcHRpb25zKHByb3h5T2JqZWN0KS5mb3JFYWNoKChzdWJzY3JpcHRpb24pID0+IHtcbiAgICBjb25zdCB7IGs6IGtleSB9ID0gc3Vic2NyaXB0aW9uO1xuICAgIGlmICghKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMua2V5cykgfHwgb3B0aW9ucy5rZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHJlbW92ZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgaWYgKGtleXNUb0RlbGV0ZSkge1xuICAgICAgICBrZXlzVG9EZWxldGUuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKGtleXNUb0RlbGV0ZSkge1xuICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGRlbGV0ZSBwcm94eU9iamVjdFtrZXldO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENvbXB1dGVkX0RFUFJFQ0FURUQocHJveHlPYmplY3QsIGNvbXB1dGVkRm5zX0ZBS0UsIHRhcmdldE9iamVjdCA9IHByb3h5T2JqZWN0KSB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiYWRkQ29tcHV0ZWQgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIGNvbnNpZGVyIHVzaW5nIGBkZXJpdmVgLiBGYWxsaW5nIGJhY2sgdG8gZW11bGF0aW9uIHdpdGggZGVyaXZlLiBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3ZhbHRpby9wdWxsLzIwMVwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBkZXJpdmVkRm5zID0ge307XG4gIE9iamVjdC5rZXlzKGNvbXB1dGVkRm5zX0ZBS0UpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlcml2ZWRGbnNba2V5XSA9IChnZXQpID0+IGNvbXB1dGVkRm5zX0ZBS0Vba2V5XShnZXQocHJveHlPYmplY3QpKTtcbiAgfSk7XG4gIHJldHVybiBkZXJpdmUoZGVyaXZlZEZucywgeyBwcm94eTogdGFyZ2V0T2JqZWN0IH0pO1xufVxuXG5mdW5jdGlvbiBwcm94eVdpdGhDb21wdXRlZF9ERVBSRUNBVEVEKGluaXRpYWxPYmplY3QsIGNvbXB1dGVkRm5zKSB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdwcm94eVdpdGhDb21wdXRlZCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgZm9sbG93IFwiQ29tcHV0ZWQgUHJvcGVydGllc1wiIGd1aWRlIGluIGRvY3MuJ1xuICAgICk7XG4gIH1cbiAgT2JqZWN0LmtleXMoY29tcHV0ZWRGbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluaXRpYWxPYmplY3QsIGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBwcm9wZXJ0eSBhbHJlYWR5IGRlZmluZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkRm4gPSBjb21wdXRlZEZuc1trZXldO1xuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IHR5cGVvZiBjb21wdXRlZEZuID09PSBcImZ1bmN0aW9uXCIgPyB7IGdldDogY29tcHV0ZWRGbiB9IDogY29tcHV0ZWRGbjtcbiAgICBjb25zdCBkZXNjID0ge307XG4gICAgZGVzYy5nZXQgPSAoKSA9PiBnZXQoc25hcHNob3QocHJveHlPYmplY3QpKTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICBkZXNjLnNldCA9IChuZXdWYWx1ZSkgPT4gc2V0KHByb3h5T2JqZWN0LCBuZXdWYWx1ZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbml0aWFsT2JqZWN0LCBrZXksIGRlc2MpO1xuICB9KTtcbiAgY29uc3QgcHJveHlPYmplY3QgPSBwcm94eShpbml0aWFsT2JqZWN0KTtcbiAgcmV0dXJuIHByb3h5T2JqZWN0O1xufVxuXG5jb25zdCBpc09iamVjdCA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsO1xubGV0IHJlZlNldDtcbmNvbnN0IGRlZXBDbG9uZSA9IChvYmopID0+IHtcbiAgaWYgKCFyZWZTZXQpIHtcbiAgICByZWZTZXQgPSB1bnN0YWJsZV9idWlsZFByb3h5RnVuY3Rpb24oKVsyXTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KG9iaikgfHwgcmVmU2V0LmhhcyhvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBjb25zdCBiYXNlT2JqZWN0ID0gQXJyYXkuaXNBcnJheShvYmopID8gW10gOiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcbiAgUmVmbGVjdC5vd25LZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgYmFzZU9iamVjdFtrZXldID0gZGVlcENsb25lKG9ialtrZXldKTtcbiAgfSk7XG4gIHJldHVybiBiYXNlT2JqZWN0O1xufTtcbmZ1bmN0aW9uIHByb3h5V2l0aEhpc3RvcnkoaW5pdGlhbFZhbHVlLCBza2lwU3Vic2NyaWJlID0gZmFsc2UpIHtcbiAgY29uc3QgcHJveHlPYmplY3QgPSBwcm94eSh7XG4gICAgdmFsdWU6IGluaXRpYWxWYWx1ZSxcbiAgICBoaXN0b3J5OiByZWYoe1xuICAgICAgd2lwOiB2b2lkIDAsXG4gICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wXG4gICAgICBzbmFwc2hvdHM6IFtdLFxuICAgICAgaW5kZXg6IC0xXG4gICAgfSksXG4gICAgY2xvbmU6IGRlZXBDbG9uZSxcbiAgICBjYW5VbmRvOiAoKSA9PiBwcm94eU9iamVjdC5oaXN0b3J5LmluZGV4ID4gMCxcbiAgICB1bmRvOiAoKSA9PiB7XG4gICAgICBpZiAocHJveHlPYmplY3QuY2FuVW5kbygpKSB7XG4gICAgICAgIHByb3h5T2JqZWN0LnZhbHVlID0gcHJveHlPYmplY3QuaGlzdG9yeS53aXAgPSBwcm94eU9iamVjdC5jbG9uZShcbiAgICAgICAgICBwcm94eU9iamVjdC5oaXN0b3J5LnNuYXBzaG90c1stLXByb3h5T2JqZWN0Lmhpc3RvcnkuaW5kZXhdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5SZWRvOiAoKSA9PiBwcm94eU9iamVjdC5oaXN0b3J5LmluZGV4IDwgcHJveHlPYmplY3QuaGlzdG9yeS5zbmFwc2hvdHMubGVuZ3RoIC0gMSxcbiAgICByZWRvOiAoKSA9PiB7XG4gICAgICBpZiAocHJveHlPYmplY3QuY2FuUmVkbygpKSB7XG4gICAgICAgIHByb3h5T2JqZWN0LnZhbHVlID0gcHJveHlPYmplY3QuaGlzdG9yeS53aXAgPSBwcm94eU9iamVjdC5jbG9uZShcbiAgICAgICAgICBwcm94eU9iamVjdC5oaXN0b3J5LnNuYXBzaG90c1srK3Byb3h5T2JqZWN0Lmhpc3RvcnkuaW5kZXhdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzYXZlSGlzdG9yeTogKCkgPT4ge1xuICAgICAgcHJveHlPYmplY3QuaGlzdG9yeS5zbmFwc2hvdHMuc3BsaWNlKHByb3h5T2JqZWN0Lmhpc3RvcnkuaW5kZXggKyAxKTtcbiAgICAgIHByb3h5T2JqZWN0Lmhpc3Rvcnkuc25hcHNob3RzLnB1c2goc25hcHNob3QocHJveHlPYmplY3QpLnZhbHVlKTtcbiAgICAgICsrcHJveHlPYmplY3QuaGlzdG9yeS5pbmRleDtcbiAgICB9LFxuICAgIHN1YnNjcmliZTogKCkgPT4gc3Vic2NyaWJlKHByb3h5T2JqZWN0LCAob3BzKSA9PiB7XG4gICAgICBpZiAob3BzLmV2ZXJ5KFxuICAgICAgICAob3ApID0+IG9wWzFdWzBdID09PSBcInZhbHVlXCIgJiYgKG9wWzBdICE9PSBcInNldFwiIHx8IG9wWzJdICE9PSBwcm94eU9iamVjdC5oaXN0b3J5LndpcClcbiAgICAgICkpIHtcbiAgICAgICAgcHJveHlPYmplY3Quc2F2ZUhpc3RvcnkoKTtcbiAgICAgIH1cbiAgICB9KVxuICB9KTtcbiAgcHJveHlPYmplY3Quc2F2ZUhpc3RvcnkoKTtcbiAgaWYgKCFza2lwU3Vic2NyaWJlKSB7XG4gICAgcHJveHlPYmplY3Quc3Vic2NyaWJlKCk7XG4gIH1cbiAgcmV0dXJuIHByb3h5T2JqZWN0O1xufVxuXG5mdW5jdGlvbiBwcm94eVNldChpbml0aWFsVmFsdWVzKSB7XG4gIGNvbnN0IHNldCA9IHByb3h5KHtcbiAgICBkYXRhOiBBcnJheS5mcm9tKG5ldyBTZXQoaW5pdGlhbFZhbHVlcykpLFxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgfSxcbiAgICBhZGQodmFsdWUpIHtcbiAgICAgIGxldCBoYXNQcm94eSA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBoYXNQcm94eSA9IHRoaXMuZGF0YS5pbmRleE9mKHByb3h5KHZhbHVlKSkgIT09IC0xO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5pbmRleE9mKHZhbHVlKSA9PT0gLTEgJiYgIWhhc1Byb3h5KSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZGVsZXRlKHZhbHVlKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGF0YS5pbmRleE9mKHZhbHVlKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgdGhpcy5kYXRhLnNwbGljZSgwKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfSxcbiAgICBmb3JFYWNoKGNiKSB7XG4gICAgICB0aGlzLmRhdGEuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgY2IodmFsdWUsIHZhbHVlLCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgcmV0dXJuIFwiU2V0XCI7XG4gICAgfSxcbiAgICB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh0aGlzLmRhdGEpO1xuICAgIH0sXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9LFxuICAgIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEudmFsdWVzKCk7XG4gICAgfSxcbiAgICBrZXlzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS52YWx1ZXMoKTtcbiAgICB9LFxuICAgIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh0aGlzLmRhdGEpLmVudHJpZXMoKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzZXQsIHtcbiAgICBkYXRhOiB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9LFxuICAgIHRvSlNPTjoge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9XG4gIH0pO1xuICBPYmplY3Quc2VhbChzZXQpO1xuICByZXR1cm4gc2V0O1xufVxuXG5mdW5jdGlvbiBwcm94eU1hcChlbnRyaWVzKSB7XG4gIGNvbnN0IG1hcCA9IHByb3h5KHtcbiAgICBkYXRhOiBBcnJheS5mcm9tKGVudHJpZXMgfHwgW10pLFxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEuc29tZSgocCkgPT4gcFswXSA9PT0ga2V5KTtcbiAgICB9LFxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICBjb25zdCByZWNvcmQgPSB0aGlzLmRhdGEuZmluZCgocCkgPT4gcFswXSA9PT0ga2V5KTtcbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgcmVjb3JkWzFdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXQoa2V5KSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5kYXRhLmZpbmQoKHApID0+IHBbMF0gPT09IGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfYVsxXTtcbiAgICB9LFxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kYXRhLmZpbmRJbmRleCgocCkgPT4gcFswXSA9PT0ga2V5KTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgdGhpcy5kYXRhLnNwbGljZSgwKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfSxcbiAgICB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcCh0aGlzLmRhdGEpO1xuICAgIH0sXG4gICAgZm9yRWFjaChjYikge1xuICAgICAgdGhpcy5kYXRhLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgY2IocFsxXSwgcFswXSwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGtleXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcCgocCkgPT4gcFswXSkudmFsdWVzKCk7XG4gICAgfSxcbiAgICB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcCgocCkgPT4gcFsxXSkudmFsdWVzKCk7XG4gICAgfSxcbiAgICBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXAodGhpcy5kYXRhKS5lbnRyaWVzKCk7XG4gICAgfSxcbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICByZXR1cm4gXCJNYXBcIjtcbiAgICB9LFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG1hcCwge1xuICAgIGRhdGE6IHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0sXG4gICAgdG9KU09OOiB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5zZWFsKG1hcCk7XG4gIHJldHVybiBtYXA7XG59XG5cbmV4cG9ydCB7IGFkZENvbXB1dGVkX0RFUFJFQ0FURUQgYXMgYWRkQ29tcHV0ZWQsIGRlcml2ZSwgZGV2dG9vbHMsIHByb3h5TWFwLCBwcm94eVNldCwgcHJveHlXaXRoQ29tcHV0ZWRfREVQUkVDQVRFRCBhcyBwcm94eVdpdGhDb21wdXRlZCwgcHJveHlXaXRoSGlzdG9yeSwgc3Vic2NyaWJlS2V5LCB1bmRlcml2ZSwgdW5zdGFibGVfZGVyaXZlU3Vic2NyaXB0aW9ucywgd2F0Y2ggfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valtio/esm/vanilla/utils.mjs\n");

/***/ })

};
;